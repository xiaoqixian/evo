// -*- C++ -*-
// Date:   Sun May 11 16:35:32 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include "evo/types"
#include <utility>
#include <variant>
#include <vector>

namespace evo {

namespace {

struct empty_node_tag {};

template <typename T>
struct node {
  using value_type = T;
  using Var = std::variant<size_t, value_type>;

  Var data_;

  node(empty_node_tag, int next) noexcept
    : data_(Var(std::in_place_index<0>, next))
  {}

  template <typename... Args>
  node(Args&&... args) noexcept(std::is_nothrow_constructible_v<T, Args...>)
    requires std::is_constructible_v<T, Args...>
    : data_(Var(std::in_place_index<1>, std::forward<Args>(args)...))
  {}

  node(node const&) noexcept(std::is_nothrow_copy_constructible_v<T>)
    requires std::is_copy_constructible_v<T> = default;

  node(node &&) noexcept(std::is_nothrow_move_constructible_v<T>)
    requires std::is_move_constructible_v<T> = default;

  void reset(int next) noexcept(std::is_nothrow_destructible_v<T>);

  template <typename... Args>
  void emplace(Args&&...) noexcept(std::is_nothrow_constructible_v<T, Args...>)
    requires std::is_constructible_v<T, Args...>;


  bool empty() const noexcept {
    return data_.index() == 0;
  }

  size_t next() const noexcept {
    return std::get<0>(data_);
  }

  T& value() noexcept {
    return std::get<1>(data_);
  }
};

template <typename T>
void node<T>::reset(int next) 
  noexcept(std::is_nothrow_destructible_v<T>)
{
  data_.template emplace<0>(next);
}

template <typename T>
template <typename... Args>
void node<T>::emplace(Args&&... args) 
  noexcept(std::is_nothrow_constructible_v<T, Args...>)
  requires std::is_constructible_v<T, Args...>
{
  data_.template emplace<1>(T(std::forward<Args>(args)...));
}

} // anonymous namespace

template <typename T>
class slab {
  using value_type = T;
  using node_t = node<value_type>;

  std::vector<node_t> slots_;
  size_t next_ {0};
  size_t size_ {0};

public:
  using key_type = u32;
  
  slab() noexcept = default;

  slab(size_t size);

  template <typename... Args>
  key_type emplace(Args&&...) 
    noexcept(std::is_nothrow_constructible_v<T, Args...>)
    requires std::is_constructible_v<T, Args...>;

  void erase(key_type);

  T& get(key_type key);

  T& operator[](key_type key) { return get(key); }
};

template <typename T>
slab<T>::slab(size_t size) {
  slots_.reserve(size);
}

template <typename T>
template <typename... Args>
slab<T>::key_type slab<T>::emplace(Args&&... args) 
  noexcept(std::is_nothrow_constructible_v<T, Args...>)
  requires std::is_constructible_v<T, Args...>
{
  auto key = next_;
  if (next_ == slots_.size()) {
    slots_.emplace_back(std::forward<Args>(args)...);
    next_++;
  } else {
    next_ = slots_[key].next();
    slots_[key].emplace(std::forward<Args>(args)...);
  }

  return key;
}

template <typename T>
void slab<T>::erase(key_type key) {
  slots_[key].reset(next_);
  next_ = key;
}

template <typename T>
T& slab<T>::get(key_type key) {
  return slots_[key].value();
}

} // namespace evo
