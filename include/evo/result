// -*- C++ -*-
// Date:   Sun May 04 11:45:54 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include <stdexcept>
#include <type_traits>
#include <utility>
#include <variant>
namespace evo {

template <typename T, typename E>
class Result {
  std::variant<T, E> value_;
  Result() = default;

public:
  template <typename U>
  requires std::is_constructible_v<T, U&&>
  static Result Ok(U&& ok) noexcept(std::is_nothrow_constructible_v<T, U&&>);

  template <typename Y>
  requires std::is_constructible_v<E, Y&&>
  static Result Err(Y&& err) noexcept(std::is_nothrow_constructible_v<E, Y&&>);

  bool is_ok() const noexcept {
    return value_.index() == 0;
  }

  bool is_err() const noexcept {
    return value_.index() == 1;
  }

  T& unwrap() &;
  T&& unwrap() &&;

  E& unwrap_err() &;
  E&& unwrap_err() &&;

  T& unchecked_unwrap() & noexcept;
  T&& unchecked_unwrap() && noexcept;

  E& unchecked_unwrap_err() & noexcept;
  E&& unchecked_unwrap_err() && noexcept;
};

template <typename T, typename E>
template <typename U>
requires std::is_constructible_v<T, U&&>
Result<T, E> Result<T, E>::Ok(U&& ok) 
  noexcept(std::is_nothrow_constructible_v<T, U&&>)
{
  return Result { std::variant(std::in_place_index<0>, std::forward<U>(ok)) };
}

template <typename T, typename E>
template <typename Y>
requires std::is_constructible_v<E, Y&&>
Result<T, E> Result<T, E>::Err(Y&& err) 
  noexcept(std::is_nothrow_constructible_v<E, Y&&>)
{
  return Result { std::variant(std::in_place_index<1>, std::forward<Y>(err)) };
}

template <typename T, typename E>
T& Result<T, E>::unwrap() & {
  if (value_.index() != 0) {
    throw std::runtime_error("unwrap on Err");
  }
  return std::get<0>(value_);
}

template <typename T, typename E>
T&& Result<T, E>::unwrap() && {
  if (value_.index() != 0) {
    throw std::runtime_error("unwrap on Err");
  }
  return std::move(std::get<0>(value_));
}

template <typename T, typename E>
E& Result<T, E>::unwrap_err() & {
  if (value_.index() != 1) {
    throw std::runtime_error("unwrap_err on Ok");
  }
  return std::get<1>(value_);
}

template <typename T, typename E>
E&& Result<T, E>::unwrap_err() && {
  if (value_.index() != 1) {
    throw std::runtime_error("unwrap_err on Ok");
  }
  return std::move(std::get<1>(value_));
}

template <typename T, typename E>
T& Result<T, E>::unchecked_unwrap() & noexcept {
  return std::get<0>(value_);
}

template <typename T, typename E>
T&& Result<T, E>::unchecked_unwrap() && noexcept {
  return std::move(std::get<0>(value_));
}

template <typename T, typename E>
E& Result<T, E>::unchecked_unwrap_err() & noexcept {
  return std::get<1>(value_);
}

template <typename T, typename E>
E&& Result<T, E>::unchecked_unwrap_err() && noexcept {
  return std::move(std::get<1>(value_));
}

} // namespace evo
