// -*- C++ -*-
// Date:   Sun May 04 11:45:54 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include "evo/debug"
#include <stdexcept>
#include <type_traits>
#include <utility>
#include <variant>

#define __RESULT_DEFINE_CONST_BOOL(name, trait)\
static constexpr bool name = trait<T> && trait<E>;

namespace evo {

template <typename T, typename E>
class Result {
  using Var = std::variant<char, T, E>;
  Var value_;

  static constexpr size_t OK_IDX = 1;
  static constexpr size_t ERR_IDX = 2;

  __RESULT_DEFINE_CONST_BOOL(BOTH_NOTHROW_COPY, std::is_nothrow_copy_constructible_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_NOTHROW_MOVE, std::is_nothrow_move_constructible_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_COPYABLE, std::is_copy_constructible_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_MOVABLE, std::is_move_constructible_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_COPY_ASSIGNABLE, std::is_copy_assignable_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_MOVE_ASSIGNABLE, std::is_move_assignable_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_NOTHROW_COPY_ASSIGNABLE, std::is_nothrow_copy_assignable_v);

  __RESULT_DEFINE_CONST_BOOL(BOTH_NOTHROW_MOVE_ASSIGNABLE, std::is_nothrow_move_assignable_v);

  Result(Var value): value_(std::move(value)) {}

public:
  using ok_type = T;
  using err_type = E;

  Result(Result const& other) noexcept(BOTH_NOTHROW_COPY)
    requires BOTH_COPYABLE
    : value_(other.value_)
  {}

  Result(Result && other) noexcept(BOTH_NOTHROW_MOVE)
    requires BOTH_MOVABLE
    : value_(std::move(other.value_))
  {}

  Result& operator=(Result const& other) noexcept(BOTH_NOTHROW_COPY_ASSIGNABLE)
    requires BOTH_COPY_ASSIGNABLE
  {
    value_ = other.value_;
    return *this;
  }

  Result& operator=(Result && other) noexcept(BOTH_NOTHROW_MOVE_ASSIGNABLE)
    requires BOTH_MOVE_ASSIGNABLE
  {
    value_ = std::move(other.value_);
    return *this;
  }

  template <typename U>
  requires std::is_constructible_v<T, U&&>
  static Result ok(U&& ok) noexcept(std::is_nothrow_constructible_v<T, U&&>);

  template <typename Y>
  requires std::is_constructible_v<E, Y&&>
  static Result err(Y&& err) noexcept(std::is_nothrow_constructible_v<E, Y&&>);

  bool is_ok() const noexcept {
    DEBUG_ASSERT(value_.index() != 0, "");
    return value_.index() == OK_IDX;
  }

  bool is_err() const noexcept {
    DEBUG_ASSERT(value_.index() != 0, "");
    return value_.index() == ERR_IDX;
  }

  T& unwrap() &;
  T&& unwrap() &&;

  E& unwrap_err() &;
  E&& unwrap_err() &&;

  T& unchecked_unwrap() & noexcept;
  T&& unchecked_unwrap() && noexcept;

  E& unchecked_unwrap_err() & noexcept;
  E&& unchecked_unwrap_err() && noexcept;
};

template <typename T, typename E>
template <typename U>
requires std::is_constructible_v<T, U&&>
Result<T, E> Result<T, E>::ok(U&& ok) 
  noexcept(std::is_nothrow_constructible_v<T, U&&>)
{
  return Result { Var(std::in_place_index<OK_IDX>, std::forward<U>(ok)) };
}

template <typename T, typename E>
template <typename Y>
requires std::is_constructible_v<E, Y&&>
Result<T, E> Result<T, E>::err(Y&& err) 
  noexcept(std::is_nothrow_constructible_v<E, Y&&>)
{
  return Result { Var(std::in_place_index<ERR_IDX>, std::forward<Y>(err)) };
}

template <typename T, typename E>
T& Result<T, E>::unwrap() & {
  if (value_.index() != OK_IDX) {
    throw std::runtime_error("unwrap on Err");
  }
  return std::get<OK_IDX>(value_);
}

template <typename T, typename E>
T&& Result<T, E>::unwrap() && {
  if (value_.index() != OK_IDX) {
    throw std::runtime_error("unwrap on Err");
  }
  return std::move(std::get<OK_IDX>(value_));
}

template <typename T, typename E>
E& Result<T, E>::unwrap_err() & {
  if (value_.index() != ERR_IDX) {
    throw std::runtime_error("unwrap_err on Ok");
  }
  return std::get<ERR_IDX>(value_);
}

template <typename T, typename E>
E&& Result<T, E>::unwrap_err() && {
  if (value_.index() != ERR_IDX) {
    throw std::runtime_error("unwrap_err on Ok");
  }
  return std::move(std::get<ERR_IDX>(value_));
}

template <typename T, typename E>
T& Result<T, E>::unchecked_unwrap() & noexcept {
  return std::get<OK_IDX>(value_);
}

template <typename T, typename E>
T&& Result<T, E>::unchecked_unwrap() && noexcept {
  return std::move(std::get<OK_IDX>(value_));
}

template <typename T, typename E>
E& Result<T, E>::unchecked_unwrap_err() & noexcept {
  return std::get<ERR_IDX>(value_);
}

template <typename T, typename E>
E&& Result<T, E>::unchecked_unwrap_err() && noexcept {
  return std::move(std::get<ERR_IDX>(value_));
}

} // namespace evo
