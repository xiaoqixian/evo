// -*- C++ -*-
// Date:   Thu May 01 12:01:28 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include "evo/coroutine/driver"
#include "evo/coroutine/context"
#include "evo/coroutine/concepts"
#include "evo/coroutine/task"
#include <coroutine>
#include <type_traits>

namespace evo::coro {

using evo::concepts::PromiseWithContinuation;

class Runtime;

struct EpollDriverTag {};

template <typename R>
class JoinHandle {
  using task_t = task<R>;
  task_t task_;

public:
  JoinHandle(task_t task) noexcept: task_(std::move(task)) {}

  bool await_ready() {
    return task_.handle().done();
  }

  void await_suspend(std::coroutine_handle<> cont) {
    task_.handle().promise().set_continuation(cont);
  }

  R await_resume() noexcept {
    if constexpr (!std::is_void_v<R>) {
      return std::move(task_.handle().promise().take_result());
    }
  }
};

class RuntimeImpl {
  friend class Runtime;

  Context ctx_;
  std::unique_ptr<Driver> driver_;
public:
  RuntimeImpl(EpollDriverTag): driver_(std::make_unique<EpollDriver>()) {}

  void block_on(std::coroutine_handle<>);

  static void resume_handle(void* data) {
    auto handle = std::coroutine_handle<>::from_address(data);
    if (!handle.done()) handle.resume();
    else {
      LOG_TRACE("try resume a finished coroutine");
    }
  }

  template <typename R>
  JoinHandle<R> spawn(task<R> task) {
    auto handle = task.handle();
    auto join_handle = JoinHandle<R>(std::move(task));
    GLOBAL_CONTEXT.ref().push(RawTask(handle.address(), &resume_handle));
    return join_handle;
  }
};

class Runtime {
  static thread_local std::unique_ptr<RuntimeImpl> thread_runtime;
public:
  static void init() {
    thread_runtime = std::make_unique<RuntimeImpl>(EpollDriverTag {});
    GLOBAL_CONTEXT.set(&thread_runtime->ctx_);
    GLOBAL_DRIVER.set(thread_runtime->driver_.get());
  }

  static void block_on(std::coroutine_handle<> h);

  template <typename R>
  inline static JoinHandle<R> spawn(task<R> task) {
    return thread_runtime->spawn(std::move(task));
  }
};

} // namespace evo::coro
