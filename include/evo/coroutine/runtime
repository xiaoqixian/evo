// -*- C++ -*-
// Date:   Thu May 01 12:01:28 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include "evo/coroutine/driver"
#include "evo/coroutine/context"
#include "evo/coroutine/concepts"
#include "evo/coroutine/task"
#include <coroutine>
#include <type_traits>

namespace evo::coro {

using evo::concepts::PromiseWithContinuation;

class Runtime;

struct EpollDriverTag {};

template <typename R>
class JoinHandle {
  using handle_t = task<R>::handle_t;
  handle_t handle_;

public:
  JoinHandle(handle_t handle) noexcept: handle_(handle) {}

  bool await_ready() {
    return handle_.done();
  }

  void await_suspend(std::coroutine_handle<> cont) {
    handle_.promise().set_continuation(cont);
  }

  R await_resume() noexcept {
    if constexpr (!std::is_void_v<R>) {
      return std::move(handle_.promise().result());
    }
  }
};

class RuntimeImpl {
  friend class Runtime;

  Context ctx_;
  std::unique_ptr<Driver> driver_;
public:
  RuntimeImpl(EpollDriverTag): driver_(std::make_unique<EpollDriver>()) {}

  void block_on(std::coroutine_handle<>);

  static void resume_handle(void* data) {
    auto handle = std::coroutine_handle<>::from_address(data);
    if (!handle.done()) handle.resume();
  }

  template <typename R>
  JoinHandle<R> spawn(task<R> task) {
    auto join_handle = JoinHandle<R>(task.handle());
    GLOBAL_CONTEXT.ref().push(RawTask(task.handle().address(), &resume_handle));
    return join_handle;
  }
};

class Runtime {
  static thread_local std::unique_ptr<RuntimeImpl> thread_runtime;
public:
  static void init() {
    thread_runtime = std::make_unique<RuntimeImpl>(EpollDriverTag {});
    GLOBAL_CONTEXT.set(&thread_runtime->ctx_);
    GLOBAL_DRIVER.set(thread_runtime->driver_.get());
  }

  static void block_on(std::coroutine_handle<> h);

  template <typename R>
  inline static JoinHandle<R> spawn(task<R> task) {
    return thread_runtime->spawn(std::move(task));
  }
};

} // namespace evo::coro
