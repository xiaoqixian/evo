// -*- C++ -*-
// Date:   Sat May 03 20:26:19 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include <coroutine>
#include <functional>
#include <sys/epoll.h>
#include "evo/types"

namespace evo::coro {

struct Ready {
  static constexpr u8 EMPTY          = 0b000000;
  static constexpr u8 READABLE       = 0b000001;
  static constexpr u8 WRITABLE       = 0b000010;
  static constexpr u8 READ_CLOSED    = 0b000100;
  static constexpr u8 WRITE_CLOSED   = 0b001000;
  static constexpr u8 READ_CANCELED  = 0b010000;
  static constexpr u8 WRITE_CANCELED = 0b100000;

  static constexpr u8 READ_ALL = READABLE | READ_CANCELED | READ_CLOSED;
  static constexpr u8 WRITE_ALL = WRITABLE | WRITE_CANCELED | WRITE_CLOSED;

  Ready(u8 val): value_(val) {}

  static Ready from_epoll_events(u32 events) {
    u8 value = EMPTY;
    if (events & EPOLLIN) {
      value |= READABLE;
    }
    if (events & EPOLLOUT) {
      value |= WRITABLE;
    }
    return Ready {value};
  }

  void set(u8 val) {
    value_ = val;
  }
  
  operator u8() const {
    return value_;
  }
  
  bool is_empty() const {
    return value_ == EMPTY;
  }

  bool is_readable() const {
    return (value_ & READ_ALL) != EMPTY;
  }

  bool is_writable() const {
    return (value_ & WRITE_ALL) != EMPTY;
  }
private:
  u8 value_ {0};
};

struct IODirection {
  static IODirection read() {
    return IODirection {false};
  }

  static IODirection write() {
    return IODirection {true};
  }

  bool is_write() const {
    return is_write_;
  }

  u8 mask() const {
    if (is_write_) {
      return Ready::WRITABLE | Ready::WRITE_CLOSED | Ready::WRITE_CANCELED;
    } else {
      return Ready::READABLE | Ready::READ_CLOSED | Ready::READ_CANCELED;
    }
  }
private:
  IODirection(bool b): is_write_(b) {}
  bool is_write_ {false};
};

template <typename W>
struct ScheduledIO {
  Ready readiness_ { Ready::EMPTY };
  W reader_;
  W writer_;

  ScheduledIO(Ready readiness, W reader, W writer):
    readiness_(readiness),
    reader_(std::move(reader)),
    writer_(std::move(writer))
  {}

  bool check_ready(IODirection, W);

  void set_waker(IODirection, W);

  void set_readiness(std::function<Ready(Ready)>);
  void wake(Ready readiness);
};

} // namespace evo::coroutine
