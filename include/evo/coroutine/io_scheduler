// -*- C++ -*-
// Date:   Sat May 03 20:26:19 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include <functional>
#include <optional>
#include <sys/epoll.h>
#include "evo/types"
#include "evo/coroutine/waker"

namespace evo::coro {

struct Readiness {
  static constexpr u8 EMPTY          = 0b000000;
  static constexpr u8 READABLE       = 0b000001;
  static constexpr u8 WRITABLE       = 0b000010;
  static constexpr u8 READ_CLOSED    = 0b000100;
  static constexpr u8 WRITE_CLOSED   = 0b001000;
  static constexpr u8 READ_CANCELED  = 0b010000;
  static constexpr u8 WRITE_CANCELED = 0b100000;

  static constexpr u8 READ_ALL = READABLE | READ_CANCELED | READ_CLOSED;
  static constexpr u8 WRITE_ALL = WRITABLE | WRITE_CANCELED | WRITE_CLOSED;

  Readiness(u8 val): value_(val) {}

  inline static Readiness from_epoll_events(u32 events) {
    u8 value = EMPTY;
    if (events & EPOLLIN) {
      value |= READABLE;
    }
    if (events & EPOLLOUT) {
      value |= WRITABLE;
    }
    if (events & EPOLLRDHUP) {
    value |= READ_CLOSED;
    }
    if (events & EPOLLHUP) {
      // 表示对端关闭写或读，保守处理为两者都关闭
      value |= READ_CLOSED | WRITE_CLOSED;
    }
    if (events & EPOLLERR) {
      value |= READ_CANCELED | WRITE_CANCELED;
    }
    return Readiness {value};
  }

  inline void set(u8 val) {
    value_ = val;
  }
  
  operator u8() const {
    return value_;
  }
  
  inline bool is_empty() const {
    return value_ == EMPTY;
  }

  inline bool is_readable() const {
    return (value_ & READ_ALL) != EMPTY;
  }

  inline bool is_writable() const {
    return (value_ & WRITE_ALL) != EMPTY;
  }
private:
  u8 value_ {0};
};

struct IODirection {
  static IODirection read() {
    return IODirection {false};
  }

  static IODirection write() {
    return IODirection {true};
  }

  inline bool is_write() const {
    return is_write_;
  }

  inline u8 mask() const {
    if (is_write_) {
      return Readiness::WRITABLE | Readiness::WRITE_CLOSED | Readiness::WRITE_CANCELED;
    } else {
      return Readiness::READABLE | Readiness::READ_CLOSED | Readiness::READ_CANCELED;
    }
  }
private:
  IODirection(bool b): is_write_(b) {}
  bool is_write_ {false};
};

struct ScheduledIO {
  Readiness readiness_ { Readiness::EMPTY };
  std::optional<Waker> reader_;
  std::optional<Waker> writer_;

  ScheduledIO() = default;

  ScheduledIO(Readiness readiness, Waker reader, Waker writer):
    readiness_(readiness),
    reader_(std::move(reader)),
    writer_(std::move(writer))
  {}

  bool check_ready(IODirection, Waker);

  void set_waker(IODirection, Waker);

  template <typename F>
  inline void set_readiness(F&& f) {
    readiness_ = f(readiness_);
  }

  void clear_readiness(Readiness mask) {
    readiness_.set(readiness_ - mask);
  }

  void wake(Readiness readiness);
};

} // namespace evo::coroutine
