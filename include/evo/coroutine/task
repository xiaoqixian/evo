// -*- C++ -*-
// Date:   Thu Mar 14 23:05:29 2024
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include <coroutine>
#include <utility>
#include "evo/coroutine/promise_base"
#include "evo/debug"
#include <fmt/format.h>

namespace evo::coro {

template <typename Ret = void>
class task;

namespace task_impl {

template <typename Ret>
struct task_promise;

template <typename Ret>
using task_promise_base = promise_base<Ret>;

template <typename Ret>
struct task_promise: task_promise_base<Ret> {
  std::coroutine_handle<> continuation_;
  size_t ref_;

  // task promise is born with 2 references, one is the coroutine itself,
  // one is with the task.
  // The coroutine one is released on final suspend
  // The task one is released on destruction.
  task_promise(): continuation_(nullptr), ref_(2) {}

  task<Ret> get_return_object() {
    return task<Ret>(std::coroutine_handle<task_promise<Ret>>::from_promise(*this));
  }

  struct final_awaiter {
    // if no other join handle refer to this coroutine,
    // the coroutine can be automatically destroyed.
    inline constexpr bool await_ready() const noexcept {
      return promise_.dec_ref() == 0;
    }

    // technically, the typename P should be a type 
    // with a continuation. 
    // TODO: I'll try to add a constraint here.
    template <typename P>
    std::coroutine_handle<> 
    await_suspend(std::coroutine_handle<P> coro) noexcept {
      auto const& prom = coro.promise();
      if ( prom.continuation_ != nullptr ) {
        return prom.continuation_;
      } else {
        return std::noop_coroutine();
      }
    }

    inline constexpr void await_resume() const noexcept {}

    task_promise<Ret>& promise_;
  };

  // actually this is an override.
  auto final_suspend() noexcept {
    return final_awaiter {*this};
  }

  void set_continuation(std::coroutine_handle<> c) noexcept {
    continuation_ = c;
  }

  size_t ref() const {
    return ref_;
  }

  size_t inc_ref() {
    return ++ref_;
  }

  size_t dec_ref() {
    return --ref_;
  }
};

} // namespace task_impl

template <typename Ret>
class task {
public:
  using promise_type = task_impl::task_promise<Ret>;
  using handle_t  = std::coroutine_handle<promise_type>;

  constexpr task() noexcept: handle_(nullptr) {}
  explicit constexpr task(handle_t h) noexcept: handle_(h) {}

  task(task const&) = delete;
  task(task&& other) noexcept 
    : handle_(std::exchange(other.handle_, nullptr)) {}

  task& operator=(task const&) = delete;
  task& operator=(task&& other) noexcept {
    if (std::addressof(other) != this) {
      if (handle_ != nullptr) {
        handle_.destroy();
      }
      handle_ = std::exchange(other.handle_, nullptr);
    }
    return *this;
  }

  ~task() {
    if (handle_ && handle_.promise().dec_ref() == 0) {
      DEBUG_ASSERT(handle_.done(), "");
      handle_.destroy();
    }
  }

  inline bool is_ready() const noexcept {
    return handle_ == nullptr || handle_.done();
  }

  inline operator bool() const noexcept {
    return is_ready();
  }

  inline void resume() noexcept {
    if (handle_ != nullptr) {
      handle_.resume();
    }
  }

  struct awaiter {
    awaiter(handle_t h) noexcept: handle_(h) {}

    inline bool await_ready() const noexcept {
      return false;
    }

    std::coroutine_handle<> 
    await_suspend(std::coroutine_handle<> continuation) noexcept {
      handle_.promise().set_continuation(continuation);
      return handle_;
    }

    Ret await_resume() const noexcept {
      if constexpr (!std::is_void_v<Ret>) {
        return handle_.promise().take_result();
      }
    }
  protected:
    handle_t handle_;
  };

  auto operator co_await() noexcept {
    return awaiter(handle_);
  }

  auto handle() const noexcept {
    return handle_;
  }

  auto take_handle() const noexcept {
    return std::exchange(handle_, nullptr);
  }
private:
  handle_t handle_;
};

} // namespace evo::coro
