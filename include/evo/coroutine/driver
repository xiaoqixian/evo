// -*- C++ -*-
// Date:   Sun May 04 12:42:59 2025
// Mail:   lunar_ubuntu@qq.com
// Author: https://github.com/xiaoqixian

#pragma once

#include "evo/coroutine/io_scheduler"
#include "evo/debug"
#include "evo/macros"
#include <sys/epoll.h>
#include <unordered_map>
#include <coroutine>
#include "evo/coroutine/utilities"

#define DRIVER_PROXY(method, ...)\
switch (driver_type_) {\
  case DriverType::Epoll:\
    return static_cast<EpollDriver*>(this)->method(__VA_ARGS__);\
  case DriverType::Empty:\
    FATAL("");\
}

namespace evo::coro {

namespace __op_detail {

template <typename T>
struct is_ready: std::false_type {};

template <typename T>
struct is_ready<Ready<T>>: std::is_move_assignable<T> {};

template <typename T>
concept IsReady = is_ready<T>::value;

} // namespace op_detail

template <typename Op>
concept OpAble = requires (Op op) {
  {op.interest()} -> std::same_as<std::tuple<int, IODirection>>;
  {op.invoke()} -> __op_detail::IsReady;
  typename Op::return_type;
};

enum class DriverType {
  Empty,
  Epoll
};

class Driver {
  DriverType driver_type_ {DriverType::Empty};
protected:
  Driver(DriverType t): driver_type_(t) {}
public:
  template <typename O>
  bool check_ready(O& op, std::coroutine_handle<> h);

  void park(int);

  void register_fd(int);
  void deregister_fd(int);

  template <typename O, typename Ret = typename O::return_type>
  Ready<Ret> poll(O& op, TaskScheme* task);
};

extern thread_local ThreadLocalWrapper<Driver> GLOBAL_DRIVER;

class EpollDriver: public Driver {
  int epfd_ {-1};
  std::unordered_map<int, ScheduledIO> io_dispatch_;
public:
  EpollDriver();

  void park(int);

  void register_fd(int);
  void deregister_fd(int);

  template <typename O, typename Ret = typename O::return_type>
  Ready<Ret> poll(O& op, TaskScheme* task);
};

template <typename O, typename Ret>
Ready<Ret> Driver::poll(O& op, TaskScheme* task) {
  DRIVER_PROXY(poll, op, task);
}

template <typename O, typename Ret>
Ready<Ret> EpollDriver::poll(O& op, TaskScheme* task) {
  auto const [idx, direction] = op.interest();
  DEBUG_ASSERT(io_dispatch_.contains(idx), "");

  auto& io = io_dispatch_[idx];
  bool is_ready = io.check_ready(direction, Waker(task));
  
  if (!is_ready) {
    return Ready<Ret>::not_ready();
  }

  auto res = op.invoke();
  if (!res.is_ready()) {
    io.clear_readiness(direction.mask());
    io.set_waker(direction, Waker(task));
  }
  return res;
}

} // namespace evo::coro
